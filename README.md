# StreetLight-asio

Данный проект является альтернативной реализацией задачи [Текст задания][1].
Оригинальное решение представлено здесь [StreetLight][2], см.[readme][3] и
[описание алгоритма][4].

В отличии от оригинального решения, базирующегося на протоколе Ethernet и
реализованного на языке C в виде модулей ядра Linux (kernel space), данное
решение базируется на основе multicast UDP и реализовано на языке C++ с
использованием библиотек [asio][5] и [boost][6].

## Сборка

Запустить `make all`

## Среда исполнения

Решение собиралось и проверялось на Ubuntu-22.04-LTS (WSL2). В связи с тем,
что на одном хосте может быть запущен только один эмулятор блока индикации (БИ)
или блока управления (БУ), то для того, чтобы ознакомиться с возможностями 
алгоритма, среда исполнения должна содержать минимум три хоста (в одной сети) 
для эмуляции различных сценариев взаимодействия блоков (2 БИ, 2БИ + 1БК, 2БК, 
3БИ, и т.д.).

### Docker

Простейшим решением является использование Docker контейнеров. Скрипт
`container_run.sh` запускает контейнер Ubuntu, в который монтируется текущая 
директория (где находятся собранные исполняемые файлы эмуляторов БУ и БИ).
Таким образом, для разворачивания среды, нужно запустить необходимое количество 
консолей, в каждой из которых выполнить следующее:  

1. Запустить контейнер `./container_run.sh`
2. Перейти в директорию с эмуляторами `cd /root/StreetLight/`
3. Запустить эмулятор БУ или БИ, например: `./client_block 0.0.0.0 239.255.0.1`

## Комментарии к решению

### Цели

Основной целью являлось знакомство с возможностями библиотеки Asio/Boost.Asio,
поэтому был выбран ранее реализованный проект с логикой, которую можно перенести
без особых изменений.

### Архитектурные решения

Оригинальное решение использовало свойства протокола Ethernet: общая шина (среда),
широковещательные сообщения и уникальность MAC адреса устройства в сети. В данном
решении, алгоритмы и бизнес-логика осталась прежней - в транспорте, широковещательные
сообщения Ethernet заменены на multicast режим протокола UDP, уникальность MAC
адреса заменена на уникальный id (Boost.Uuids).

### Design limitations

Необходимость переноса бизнес-логики (без сильных изменений) привёл к определенным
ограничениям. Так, дизайн текущего решения с точки зрения ООП не является оптимальным,
также, требование простоты, которому я всегда стараюсь следовать, тоже не в полной мере
реализовано. 

Так как БУ является вырожденной формой БИ, для максимального повторного использования
исполняемого кода, функциональность БУ была реализована в виде базого класса, а БИ -
наследованием от БУ. Так как операции БИ требуют доступа к механизмам БУ, private 
модификаторы не использовались в классах, только public и protected.

Ещё одно не самое элегантное (но эффективное) решение, вызванное ограничениями выше,
связано с необходимостью отправлять корректный признак блока (БИ или БУ) из функции,
реализованной в базовом классе, которая может вызываться как из объекта базового 
класса (БУ), так и наследника (БИ). Таким решением стало сравнение typeid базового
класса с typeid *this.

[1]: https://github.com/Vmogilki/StreetLight/blob/master/%D0%A2%D0%B5%D0%BA%D1%81%D1%82%20%D0%B7%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F.txt
[2]: https://github.com/Vmogilki/StreetLight
[3]: https://github.com/Vmogilki/StreetLight/blob/master/README.RUS
[4]: https://github.com/Vmogilki/StreetLight/blob/master/%D0%9E%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%B0.txt
[5]: https://think-async.com/Asio/
[6]: https://www.boost.org/